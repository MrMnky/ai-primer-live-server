<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Map Editor — Greenwich Peninsula</title>
  <style>
    *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
    html, body { width:100%; height:100%; overflow:hidden; background:#0a0a0a; font-family:'Segoe UI',system-ui,sans-serif; color:#fff; }
    #canvas { width:100%; height:100%; display:block; }

    .top-bar {
      position:fixed; top:0; left:0; right:0; z-index:10;
      padding:10px 20px;
      background:linear-gradient(180deg, rgba(0,0,0,0.75) 0%, transparent 100%);
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .top-bar h1 { font-size:13px; font-weight:600; color:rgba(255,255,255,0.8); margin-right:auto; }

    .btn {
      padding:5px 12px; border-radius:6px; border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.06); color:rgba(255,255,255,0.7);
      font-size:10px; font-weight:500; cursor:pointer; transition:all 0.15s;
      white-space:nowrap;
    }
    .btn:hover { background:rgba(255,255,255,0.12); color:#fff; }
    .btn.active { background:rgba(0,255,188,0.15); border-color:rgba(0,255,188,0.3); color:#00FFBC; }

    /* Info panel */
    .info-panel {
      position:fixed; bottom:20px; left:20px; z-index:10;
      background:rgba(0,0,0,0.8); border:1px solid rgba(255,255,255,0.08);
      border-radius:10px; padding:14px 18px; min-width:min(250px, calc(100vw - 40px));
      backdrop-filter:blur(12px); display:none;
    }
    .ip-title { font-size:13px; font-weight:600; margin-bottom:8px; color:#00FFBC; }
    .ip-row { font-size:10px; color:rgba(255,255,255,0.4); margin-bottom:4px; display:flex; align-items:center; gap:6px; }
    .ip-row span { color:rgba(255,255,255,0.75); }
    .ip-hint { font-size:9px; color:rgba(0,255,188,0.5); margin-top:10px; line-height:1.5; }

    /* Roof controls (visible when building selected in drag mode) */
    .roof-controls {
      position:fixed; bottom:20px; right:20px; z-index:10;
      background:rgba(0,0,0,0.8); border:1px solid rgba(255,255,255,0.08);
      border-radius:10px; padding:14px 18px; min-width:min(200px, calc(100vw - 40px));
      backdrop-filter:blur(12px); display:none;
    }
    .roof-controls h3 { font-size:11px; font-weight:600; margin-bottom:10px; color:#fff; }
    .roof-slider-group { margin-bottom:12px; }
    .roof-slider-group label { display:block; font-size:9px; color:rgba(255,255,255,0.5); margin-bottom:4px; }
    .roof-slider-group input[type='range'] { width:100%; height:3px; background:rgba(255,255,255,0.1); border-radius:2px; cursor:pointer; accent-color:#00FFBC; }

    /* Mobile adjustments */
    @media (max-width: 640px) {
      .top-bar {
        padding: 8px 12px;
        gap: 8px;
      }
      .top-bar h1 {
        font-size: 12px;
      }
      .btn {
        padding: 4px 10px;
        font-size: 9px;
      }
      .info-panel {
        bottom: 10px;
        left: 10px;
        padding: 10px 14px;
        font-size: 9px;
      }
      .roof-controls {
        bottom: 10px;
        right: 10px;
        padding: 10px 14px;
      }
      .roof-controls h3 {
        font-size: 10px;
      }
    }

    @media (max-width: 320px) {
      .top-bar {
        padding: 6px 8px;
        gap: 4px;
      }
      .top-bar h1 {
        font-size: 10px;
      }
      .btn {
        padding: 3px 8px;
        font-size: 8px;
      }
      .info-panel {
        bottom: 8px;
        left: 8px;
        padding: 8px 10px;
        font-size: 8px;
      }
      .roof-controls {
        bottom: 8px;
        right: 8px;
        padding: 8px 10px;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="top-bar">
    <h1>3D Map Editor — Greenwich Peninsula</h1>
    <button class="btn active" id="orbitBtn">Orbit</button>
    <button class="btn" id="dragBtn">Drag</button>
    <button class="btn" id="heightBtn">Height</button>
    <button class="btn" id="pitchBtn">Roof Pitch</button>
    <button class="btn" id="resetBtn">Reset</button>
    <button class="btn" id="exportBtn">Export JSON</button>
  </div>

  <div class="info-panel" id="infoPanel">
    <div class="ip-title" id="ipName">Building</div>
    <div class="ip-row">Type: <span id="ipType">–</span></div>
    <div class="ip-row">Height: <span id="ipHeight">–</span> m</div>
    <div class="ip-row">Roof Pitch: <span id="ipPitch">–</span>°</div>
    <div class="ip-row">Direction: <span id="ipDir">–</span>°</div>
    <div class="ip-hint" id="ipHint"></div>
  </div>

  <div class="roof-controls" id="roofControls">
    <h3>Roof Tilt</h3>
    <div class="roof-slider-group">
      <label for="pitchSlider">Pitch (degrees)</label>
      <input type="range" id="pitchSlider" min="0" max="45" value="0">
    </div>
    <div class="roof-slider-group">
      <label for="directionSlider">Direction (degrees)</label>
      <input type="range" id="directionSlider" min="0" max="360" value="0">
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ═══════════════════════════════════════════
    // POSTMESSAGE PROTOCOL & STATE
    // ═══════════════════════════════════════════
    let graphicReadySignaled = false;

    // Listen for incoming PostMessage commands
    window.addEventListener('message', function(e) {
      if (!e.data) return;
      
      // Log interaction in parent frame if available
      function logInteraction(action, data) {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({
            type: 'LOG_INTERACTION',
            action: action,
            timestamp: new Date().toISOString(),
            data: data
          }, '*');
        }
      }

      // Handle RESET command
      if (e.data.type === 'RESET') {
        window.resetAll();
        logInteraction('RESET', { timestamp: new Date().toISOString() });
      }
    });

    // ═══════════════════════════════════════════
    // SCENE SETUP
    // ═══════════════════════════════════════════
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowShadowMap;
    renderer.setClearColor(0x0a0a0a);

    let mode = 'orbit'; // orbit, drag, height, pitch
    let orbitRadius = 300;
    let orbitPhi = 1.2, orbitTheta = 0.7;

    // ═══════════════════════════════════════════
    // LIGHTING
    // ═══════════════════════════════════════════
    scene.add(new THREE.AmbientLight(0x334455, 0.6));
    const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
    sun.position.set(100, 200, 150);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    const sc = sun.shadow.camera;
    sc.left = sc.bottom = -400; sc.right = sc.top = 400; sc.near = 1; sc.far = 800;
    scene.add(sun);
    const fill = new THREE.DirectionalLight(0x4488aa, 0.4);
    fill.position.set(-80, 60, -100);
    scene.add(fill);

    // Ground + grid
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1200, 1200),
      new THREE.MeshStandardMaterial({ color:0x151b22, roughness:0.95 })
    );
    ground.rotation.x = -Math.PI / 2; ground.position.y = -0.1;
    ground.receiveShadow = true; scene.add(ground);
    scene.add(new THREE.GridHelper(1200, 120, 0x1a2233, 0x141a22));

    // ═══════════════════════════════════════════
    // BUILD GEOMETRY WITH ROOF TILT
    // ═══════════════════════════════════════════
    const TYPE_COLORS = {
      apartments:0x3a6b8a, commercial:0x4a7a6a, office:0x5a6a8a,
      university:0x6a5a8a, residential:0x4a6a7a, industrial:0x5a5a5a,
      retail:0x5a7a5a, construction:0x7a6a4a
    };
    const DEFAULT_COLOR = 0x3a5a6a;

    const entries = []; // our working data
    const meshes = [];
    const meshToEntry = new Map();

    function buildingCentre(fp) {
      let cx = 0, cz = 0;
      for (const [x, z] of fp) { cx += x; cz += z; }
      return [cx / fp.length, cz / fp.length];
    }

    function createBuildingGeo(fp, height, pitch, direction) {
      // pitch: degrees of roof tilt (0 = flat)
      // direction: degrees rotation of tilt axis
      const shape = new THREE.Shape();
      shape.moveTo(fp[0][0], fp[0][1]);
      for (let i = 1; i < fp.length; i++) shape.lineTo(fp[i][0], fp[i][1]);
      shape.closePath();

      const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });

      if (pitch > 0) {
        const positions = geo.attributes.position.array;
        const [cx, cz] = buildingCentre(fp);
        const radDir = (direction * Math.PI) / 180;
        const cosd = Math.cos(radDir), sind = Math.sin(radDir);
        const rad = (pitch * Math.PI) / 180;
        const tanP = Math.tan(rad);

        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i], z = positions[i + 2], y = positions[i + 1];
          const dx = x - cx, dz = z - cz;
          const proj = dx * cosd + dz * sind;
          const offset = proj * tanP;
          positions[i + 1] = Math.max(0, y + offset);
        }
        geo.computeVertexNormals();
      }

      return geo;
    }

    // Import buildings from external data (or use defaults)
    const buildingData = [
      { id:'b1', name:'Main Tower', type:'office', footprint:[[10,-40],[80,-40],[80,40],[10,40]], height:90 },
      { id:'b2', name:'East Wing', type:'commercial', footprint:[[-100,-60],[-30,-60],[-30,10],[-100,10]], height:45 },
      { id:'b3', name:'North Hub', type:'apartments', footprint:[[30,80],[110,80],[110,140],[30,140]], height:75 },
      { id:'b4', name:'South Plaza', type:'retail', footprint:[[-80,-120],[40,-120],[40,-60],[-80,-60]], height:25 },
      { id:'b5', name:'Lab Complex', type:'university', footprint:[[120,20],[200,20],[200,90],[120,90]], height:60 }
    ];

    buildingData.forEach(bd => {
      const entry = {
        id: bd.id,
        name: bd.name,
        type: bd.type,
        footprint: bd.footprint,
        height: bd.height,
        originalHeight: bd.height,
        pitch: 0,
        originalPitch: 0,
        direction: 0,
        originalDirection: 0,
        baseColor: TYPE_COLORS[bd.type] || DEFAULT_COLOR,
        mesh: null
      };

      const geo = createBuildingGeo(entry.footprint, entry.height, 0, 0);
      const mat = new THREE.MeshStandardMaterial({
        color: entry.baseColor,
        metalness: 0.1,
        roughness: 0.7
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      entry.mesh = mesh;
      meshToEntry.set(mesh, entry);
      entries.push(entry);
    });

    function rebuildMesh(entry) {
      if (entry.mesh) scene.remove(entry.mesh);
      const geo = createBuildingGeo(entry.footprint, entry.height, entry.pitch, entry.direction);
      const mat = new THREE.MeshStandardMaterial({
        color: entry.baseColor,
        metalness: 0.1,
        roughness: 0.7
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      entry.mesh = mesh;
      meshToEntry.set(mesh, entry);
    }

    function raycast(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = ((evt.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((evt.clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
      return raycaster.intersectObjects(meshes);
    }

    // Update mesh list when needed
    function updateMeshList() {
      meshes.length = 0;
      entries.forEach(e => { if (e.mesh) meshes.push(e.mesh); });
    }
    updateMeshList();

    // ═══════════════════════════════════════════
    // CAMERA CONTROL
    // ═══════════════════════════════════════════
    function updateCamera() {
      const x = orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
      const y = orbitRadius * Math.cos(orbitPhi);
      const z = orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
      camera.position.set(x, y, z);
      camera.lookAt(0, 20, 0);
    }

    // ═══════════════════════════════════════════
    // UI STATE
    // ═══════════════════════════════════════════
    let selectedEntry = null;
    let hoveredEntry = null;

    function showInfo(entry) {
      const panel = document.getElementById('infoPanel');
      document.getElementById('ipName').textContent = entry.name;
      document.getElementById('ipType').textContent = entry.type;
      document.getElementById('ipHeight').textContent = entry.height.toFixed(1);
      document.getElementById('ipPitch').textContent = entry.pitch.toFixed(0);
      document.getElementById('ipDir').textContent = entry.direction.toFixed(0);

      if (mode === 'drag') document.getElementById('ipHint').textContent = 'Click to move. Drag height slider to adjust.';
      else if (mode === 'height') document.getElementById('ipHint').textContent = 'Drag up/down to change height.';
      else if (mode === 'pitch') document.getElementById('ipHint').textContent = 'Use roof controls on the right.';
      else document.getElementById('ipHint').textContent = '';

      panel.style.display = 'block';
    }

    function hideInfo() {
      document.getElementById('infoPanel').style.display = 'none';
    }

    function deselect() {
      if (selectedEntry) {
        selectedEntry.mesh.material.color.setHex(selectedEntry.baseColor);
        selectedEntry.mesh.material.emissive.setHex(0x000000);
        selectedEntry = null;
      }
    }

    function setMode(m) {
      mode = m;
      document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
      if (m === 'orbit') document.getElementById('orbitBtn').classList.add('active');
      else if (m === 'drag') document.getElementById('dragBtn').classList.add('active');
      else if (m === 'height') document.getElementById('heightBtn').classList.add('active');
      else if (m === 'pitch') document.getElementById('pitchBtn').classList.add('active');

      if (m === 'pitch') {
        document.getElementById('roofControls').style.display = selectedEntry ? 'block' : 'none';
      } else {
        document.getElementById('roofControls').style.display = 'none';
      }

      canvas.style.cursor = m === 'orbit' ? 'grab' : 'crosshair';
    }

    // ═══════════════════════════════════════════
    // BUTTONS
    // ═══════════════════════════════════════════
    document.getElementById('orbitBtn').addEventListener('click', () => { setMode('orbit'); deselect(); hideInfo(); });
    document.getElementById('dragBtn').addEventListener('click', () => setMode('drag'));
    document.getElementById('heightBtn').addEventListener('click', () => setMode('height'));
    document.getElementById('pitchBtn').addEventListener('click', () => setMode('pitch'));
    document.getElementById('resetBtn').addEventListener('click', () => {
      window.resetAll();
    });
    document.getElementById('exportBtn').addEventListener('click', () => {
      window.exportJSON();
    });

    // Roof controls sliders
    document.getElementById('pitchSlider').addEventListener('input', (e) => {
      if (selectedEntry) {
        selectedEntry.pitch = parseFloat(e.target.value);
        rebuildMesh(selectedEntry);
        updateMeshList();
        document.getElementById('ipPitch').textContent = selectedEntry.pitch.toFixed(0);
      }
    });

    document.getElementById('directionSlider').addEventListener('input', (e) => {
      if (selectedEntry) {
        selectedEntry.direction = parseFloat(e.target.value);
        rebuildMesh(selectedEntry);
        updateMeshList();
        document.getElementById('ipDir').textContent = selectedEntry.direction.toFixed(0);
      }
    });

    // ═══════════════════════════════════════════
    // MOUSE INTERACTION
    // ═══════════════════════════════════════════
    let isOrbiting = false, isPanning = false, isDragging = false;
    let dragStartX, dragStartY, dragStartVal;

    canvas.addEventListener('mousedown', (e) => {
      if (mode === 'orbit') {
        isOrbiting = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        canvas.style.cursor = 'grabbing';
        return;
      }

      if (e.button === 2) {
        isPanning = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        return;
      }

      const hits = raycast(e);
      if (hits.length === 0) { deselect(); hideInfo(); return; }

      const entry = meshToEntry.get(hits[0].object);
      if (!entry) return;

      if (mode === 'drag') {
        selectedEntry = entry;
        entry.mesh.material.color.setHex(0x00FFBC);
        entry.mesh.material.emissive.setHex(0x001a11);
        showInfo(entry);
        isDragging = false;
        document.getElementById('roofControls').style.display = 'none';
      } else if (mode === 'height') {
        selectedEntry = entry;
        entry.mesh.material.color.setHex(0x00FFBC);
        entry.mesh.material.emissive.setHex(0x001a11);
        showInfo(entry);
        isDragging = true;
        dragStartY = e.clientY;
        dragStartVal = entry.height;
      } else if (mode === 'pitch') {
        selectedEntry = entry;
        entry.mesh.material.color.setHex(0x00FFBC);
        entry.mesh.material.emissive.setHex(0x001a11);
        showInfo(entry);
        document.getElementById('pitchSlider').value = entry.pitch;
        document.getElementById('directionSlider').value = entry.direction;
        document.getElementById('roofControls').style.display = 'block';
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isOrbiting) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        orbitTheta -= dx * 0.005;
        orbitPhi -= dy * 0.005;
        orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));
        return;
      }

      if (isPanning) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        const panSpeed = orbitRadius * 0.001;
        camera.position.x -= dx * panSpeed;
        camera.position.z += dy * panSpeed;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        return;
      }

      if (isDragging && selectedEntry) {
        const dy = dragStartY - e.clientY;
        selectedEntry.height = Math.max(2, dragStartVal + dy * 0.5);
        rebuildMesh(selectedEntry);
        updateMeshList();
        document.getElementById('ipHeight').textContent = selectedEntry.height.toFixed(1);
        return;
      }

      // Hover (height or roof mode)
      if (mode !== 'orbit') {
        const hits = raycast(e);
        // Unhover previous
        if (hoveredEntry && (!hits.length || meshToEntry.get(hits[0].object) !== hoveredEntry)) {
          if (hoveredEntry !== selectedEntry) {
            hoveredEntry.mesh.material.color.setHex(hoveredEntry.baseColor);
            hoveredEntry.mesh.material.emissive.setHex(0x000000);
          }
          hoveredEntry = null;
        }
        if (hits.length > 0) {
          const e2 = meshToEntry.get(hits[0].object);
          if (e2 && e2 !== selectedEntry) {
            hoveredEntry = e2;
            e2.mesh.material.color.setHex(0x00FFBC);
            e2.mesh.material.emissive.setHex(0x001a11);
          }
          showInfo(e2 || selectedEntry);
          canvas.style.cursor = mode === 'height' ? 'pointer' : 'pointer';
        } else if (!selectedEntry) {
          hideInfo();
          canvas.style.cursor = 'crosshair';
        }
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (e.button === 2) { isPanning = false; return; }
      if (isOrbiting) { isOrbiting = false; canvas.style.cursor = 'grab'; }
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'crosshair';
      }
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      orbitRadius = Math.max(50, Math.min(1000, orbitRadius + e.deltaY * 0.5));
    }, { passive:false });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ═══════════════════════════════════════════
    // RESET & EXPORT
    // ═══════════════════════════════════════════
    window.resetAll = function() {
      deselect(); hideInfo();
      entries.forEach(e => {
        e.height = e.originalHeight;
        e.pitch = e.originalPitch;
        e.direction = e.originalDirection;
        rebuildMesh(e);
      });
      updateMeshList();
    };

    window.exportJSON = function() {
      const out = entries.map(e => ({
        id: e.id, name: e.name, type: e.type,
        height: Math.round(e.height * 10) / 10,
        originalHeight: e.originalHeight,
        pitch: Math.round(e.pitch),
        direction: Math.round(e.direction),
        footprint: e.footprint
      }));
      const blob = new Blob([JSON.stringify(out, null, 2)], { type:'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'greenwich-buildings.json';
      a.click();
    };

    // ═══════════════════════════════════════════
    // RESIZE & LOOP
    // ═══════════════════════════════════════════
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      updateCamera();
      renderer.render(scene, camera);
    }

    updateCamera();
    setMode('orbit');
    animate();

    // ═══════════════════════════════════════════
    // SIGNAL GRAPHIC_READY TO PARENT FRAME
    // ═══════════════════════════════════════════
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'GRAPHIC_READY',
        graphicId: '3d-map-editor',
        timestamp: new Date().toISOString()
      }, '*');
      graphicReadySignaled = true;
    }
  })();
  </script>
</body>
</html>

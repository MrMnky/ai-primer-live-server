<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Leadership · Lab · Crowd — AI Operating Model</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
    html, body {
      width:100%; height:100%; overflow:hidden;
      background:#1B2F3C; font-family:'Poppins',sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    /* ── Floating info panel ── */
    #info {
      position:fixed; z-index:10; pointer-events:none;
      opacity:0; transform:translateY(8px) scale(0.97);
      transition: opacity 0.2s ease, transform 0.2s ease;
      background:rgba(27,47,60,0.92);
      border:1px solid rgba(0,255,188,0.15);
      border-radius:12px; padding:14px 18px;
      max-width:240px; min-width:150px;
      backdrop-filter:blur(16px); -webkit-backdrop-filter:blur(16px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.35);
    }
    #info.visible { opacity:1; transform:translateY(0) scale(1); }
    #info .tier {
      font-size:9px; font-weight:600; letter-spacing:1.5px;
      text-transform:uppercase; margin-bottom:4px;
    }
    #info .name {
      color:#fff; font-size:14px; font-weight:600;
      margin-bottom:6px; line-height:1.3;
    }
    #info .desc {
      color:rgba(255,255,255,0.55); font-size:11px;
      line-height:1.5; font-weight:300;
    }

    /* ── Title overlay ── */
    .title {
      position:fixed; top:20px; left:50%; transform:translateX(-50%);
      text-align:center; z-index:5; pointer-events:none;
      max-width:90%;
      padding: 0 10px;
    }
    .title h1 {
      color:rgba(255,255,255,0.8); font-size:15px; font-weight:600;
      letter-spacing:0.5px;
    }
    .title p {
      color:rgba(255,255,255,0.25); font-size:10px; font-weight:300;
      margin-top:3px; letter-spacing:0.3px;
    }

    /* ── Hint ── */
    .hint {
      position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
      color:rgba(255,255,255,0.15); font-size:10px; font-weight:300;
      pointer-events:none; z-index:5; letter-spacing:0.3px;
      transition: opacity 2s ease;
      padding: 0 10px;
      text-align: center;
      max-width: 90%;
    }
    .hint.hidden { opacity:0; }

    /* ── Mobile responsive adjustments ── */
    @media (max-width: 640px) {
      .title h1 {
        font-size:13px;
      }
      .title p {
        font-size:9px;
      }
      .hint {
        font-size:9px;
        bottom:14px;
      }
      #info {
        max-width:200px; min-width:140px;
        padding:12px 14px;
        font-size:10px;
      }
      #info .name {
        font-size:12px;
      }
      #info .desc {
        font-size:10px;
      }
    }

    @media (max-width: 360px) {
      .title h1 {
        font-size:12px;
      }
      .title p {
        font-size:8px;
      }
      .hint {
        font-size:8px;
        bottom:10px;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      canvas {
        -webkit-user-select: none;
        user-select: none;
      }
    }
  </style>
</head>
<body>
  <div class="title">
    <h1>Leadership · Lab · Crowd</h1>
    <p>Enterprise AI Operating Model</p>
  </div>

  <canvas id="c"></canvas>

  <div id="info">
    <div class="tier" id="info-tier"></div>
    <div class="name" id="info-name"></div>
    <div class="desc" id="info-desc"></div>
  </div>

  <div class="hint" id="hint">Hover or touch the nodes to explore</div>

  <script>
  (function() {
    'use strict';

    // ── PostMessage Protocol ──────────────────────────────────
    const postMessageReady = () => {
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'GRAPHIC_READY', timestamp: Date.now() }, '*');
      }
    };

    const handleParentMessage = (e) => {
      if (!e.data) return;

      if (e.data.type === 'RESET') {
        // Reset graphic to initial state
        tappedNode = null;
        hovered = null;
        dragging = null;
        mouse = { x: -9999, y: -9999 };
        interacted = false;
        infoEl.classList.remove('visible');
        hintEl.classList.remove('hidden');

        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'LOG_INTERACTION',
            action: 'reset',
            timestamp: Date.now()
          }, '*');
        }
      }
    };

    window.addEventListener('message', handleParentMessage);

    // ── Brand palette ────────────────────────────────────────
    const C = {
      bg:         '#1B2F3C',
      turquoise:  '#00FFBC',
      blue:       '#00B1FF',
      malibu:     '#5CD5FF',
      meadow:     '#17CE95',
      cornflower: '#6161FF',
      moonRaker:  '#C5B6F1',
      seaPink:    '#EFACA8',
      red:        '#FF5F5F',
    };

    // ── Utilities ────────────────────────────────────────────
    const TAU = Math.PI * 2;
    const rand  = (a, b) => Math.random() * (b - a) + a;
    const lerp  = (a, b, t) => a + (b - a) * t;
    const dist2 = (x1, y1, x2, y2) => (x2 - x1) ** 2 + (y2 - y1) ** 2;
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    function hexRgb(hex) {
      return {
        r: parseInt(hex.slice(1, 3), 16),
        g: parseInt(hex.slice(3, 5), 16),
        b: parseInt(hex.slice(5, 7), 16),
      };
    }

    // ── Tier definitions ─────────────────────────────────────
    const TIERS = [
      {
        label: 'Leadership', sub: 'Strategic Direction',
        color: C.blue, accentColor: C.malibu,
        direction: 1,
        nodes: [
          { label: 'Strategy',      color: C.blue,      desc: 'AI vision and strategic alignment' },
          { label: 'Governance',    color: C.malibu,    desc: 'Policy, standards, and oversight' },
          { label: 'Ethics & Risk', color: C.moonRaker, desc: 'Responsible AI guardrails' },
        ],
      },
      {
        label: 'Lab', sub: 'Process & Systems',
        color: C.turquoise, accentColor: C.meadow,
        direction: -1,
        nodes: [
          { label: 'Use Cases',    color: C.meadow,     desc: '1,000+ validated applications' },
          { label: 'Tooling',      color: C.blue,       desc: 'Right tech for the context' },
          { label: 'Prompt Craft', color: C.turquoise,  desc: 'Structured interaction design' },
          { label: 'Automation',   color: C.malibu,     desc: 'Workflow and process AI' },
          { label: 'Integration',  color: C.cornflower, desc: 'Connecting AI to real systems' },
        ],
      },
      {
        label: 'Crowd', sub: 'People & Culture',
        color: C.meadow, accentColor: C.turquoise,
        direction: 1,
        nodes: [
          { label: 'Training',      color: C.turquoise,  desc: 'Hands-on capability building' },
          { label: 'Champions',     color: C.moonRaker,  desc: 'Internal advocates who scale' },
          { label: 'Culture',       color: C.seaPink,    desc: 'Mindset shift across teams' },
          { label: 'Communication', color: C.malibu,     desc: 'Narrative and change comms' },
          { label: 'Support',       color: C.meadow,     desc: 'Ongoing enablement and help' },
          { label: 'Community',     color: C.red,        desc: 'Shared learning, peer networks' },
        ],
      },
    ];

    // ── Canvas & state ───────────────────────────────────────
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    const infoEl = document.getElementById('info');
    const hintEl = document.getElementById('hint');

    let W, H, dpr;
    let center = { x: 0, y: 0 };
    let ellipses = [];        // computed geometry per tier
    let allNodes = [];
    let orbitParticles = [];
    let ambientParticles = [];
    let bridgeParticles = [];  // inter-tier flow particles
    let mouse = { x: -9999, y: -9999 };
    let hovered = null;
    let dragging = null;
    let tappedNode = null;
    let time = 0;
    let interacted = false;

    // 3D rotation state
    let globalAngle = 0;
    const ROTATION_SPEED = 0.10;  // radians per second — slow, elegant rotation
    const PERSPECTIVE_STRENGTH = 0.45;  // how much rx compresses at edge-on
    const TIER_PHASE_OFFSET = 0.35;  // stagger per tier for visual depth

    // ── Resize ───────────────────────────────────────────────
    function resize() {
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width  = W * dpr;
      canvas.height = H * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      center.x = W / 2;
      center.y = H / 2;
    }

    // ── Ellipse geometry (base — 3D rotation applied in update) ──
    function computeEllipses() {
      const figH    = H * 0.78;
      const spacing = figH / 3.2;
      const baseR   = spacing * 0.82;
      const isMobile = W < 768;

      ellipses = TIERS.map((tier, i) => {
        const scale = 0.88 + i * 0.06;
        const rx = baseR * 0.58 * scale * (isMobile ? 1.1 : 1);
        const ry = baseR * 0.78 * scale;
        return {
          cx:       center.x,
          cy:       center.y + (i - 1) * spacing,
          baseRx:   rx,   // store base values
          ry:       ry,
          rx:       rx,   // this will be modulated by 3D rotation
          rotation: 0,    // now driven by globalAngle
        };
      });
    }

    function ellipsePoint(e, t) {
      const cr = Math.cos(e.rotation), sr = Math.sin(e.rotation);
      const ct = Math.cos(t),          st = Math.sin(t);
      return {
        x: e.cx + e.rx * ct * cr - e.ry * st * sr,
        y: e.cy + e.rx * ct * sr + e.ry * st * cr,
      };
    }

    // ── Update 3D rotation on ellipses ─────────────────────
    function updateEllipse3D() {
      for (let i = 0; i < ellipses.length; i++) {
        const e = ellipses[i];
        const tierAngle = globalAngle + i * TIER_PHASE_OFFSET;

        // 3D rotation modulates the horizontal radius (rx)
        // At edge-on, rx shrinks; at face-on, rx is at full width
        const perspective = Math.cos(tierAngle);
        const absPerspective = Math.abs(perspective);
        e.rx = e.baseRx * (1 - PERSPECTIVE_STRENGTH + PERSPECTIVE_STRENGTH * absPerspective);

        // Rotation tilt also shifts with the 3D angle
        // Creates the appearance of rotating around a central vertical axis
        e.rotation = Math.sin(tierAngle) * 0.35;
      }
    }

    // ── Nodes ────────────────────────────────────────────────
    function createNodes() {
      allNodes = [];
      TIERS.forEach((tier, ti) => {
        tier.nodes.forEach((nd, ni) => {
          const angle = (ni / tier.nodes.length) * TAU + rand(-0.08, 0.08);
          allNodes.push({
            tier:      ti,
            tierLabel: tier.label,
            label:     nd.label,
            desc:      nd.desc,
            color:     nd.color,
            rgb:       hexRgb(nd.color),
            angle:     angle,
            baseSpeed: rand(0.05, 0.10) * tier.direction,
            x: 0, y: 0,
            size:       W < 768 ? 11 : 14,
            baseSize:   W < 768 ? 11 : 14,
            targetSize: W < 768 ? 11 : 14,
            hovered:    false,
            phase:      rand(0, TAU),
          });
        });
      });
    }

    // ── Particles ────────────────────────────────────────────
    function createParticles() {
      const isMobile = W < 768;

      // Orbit particles — tiny dots flowing along each ellipse
      orbitParticles = [];
      TIERS.forEach((tier, ti) => {
        const count = isMobile ? 18 : 35 + tier.nodes.length * 4;
        const rgb = hexRgb(tier.color);
        for (let i = 0; i < count; i++) {
          orbitParticles.push({
            tier:  ti,
            angle: rand(0, TAU),
            speed: rand(0.15, 0.45) * tier.direction,
            size:  rand(0.6, 2.0),
            alpha: rand(0.12, 0.40),
            rgb:   rgb,
            phase: rand(0, TAU),
          });
        }
      });

      // Ambient particles — free-floating background
      ambientParticles = [];
      const ambientCount = isMobile ? 30 : Math.min(70, Math.floor(W * H / 12000));
      const palettePick = [C.turquoise, C.blue, C.malibu, C.meadow, C.cornflower, C.moonRaker];
      for (let i = 0; i < ambientCount; i++) {
        ambientParticles.push({
          x:     rand(0, W),
          y:     rand(0, H),
          vx:    rand(-0.12, 0.12),
          vy:    rand(-0.12, 0.12),
          size:  rand(0.4, 1.5),
          alpha: rand(0.04, 0.14),
          rgb:   hexRgb(palettePick[Math.floor(rand(0, palettePick.length))]),
          phase: rand(0, TAU),
        });
      }

      // Bridge particles — flow between adjacent tiers
      bridgeParticles = [];
      const bridgeCount = isMobile ? 6 : 14;
      for (let ji = 0; ji < 2; ji++) {  // junction 0: Leadership↔Lab, junction 1: Lab↔Crowd
        for (let i = 0; i < bridgeCount; i++) {
          const goingDown = Math.random() < 0.5;
          bridgeParticles.push({
            junction:  ji,
            t:         rand(0, 1),             // progress along arc 0→1
            speed:     rand(0.12, 0.35),
            size:      rand(1.0, 2.2),
            alpha:     rand(0.2, 0.5),
            goingDown: goingDown,              // direction: upper→lower or lower→upper
            exitAngle: rand(-0.6, 0.6),       // where on source ellipse the particle departs
            phase:     rand(0, TAU),
            trail:     [],
          });
        }
      }
    }

    // ── Bridge particle arc ────────────────────────────────
    // Computes position for a particle traveling between two tier ellipses
    function bridgePos(bp) {
      const srcIdx = bp.goingDown ? bp.junction : bp.junction + 1;
      const dstIdx = bp.goingDown ? bp.junction + 1 : bp.junction;
      const srcE = ellipses[srcIdx];
      const dstE = ellipses[dstIdx];

      // Departure and arrival points on the ellipses
      const srcAngle = bp.goingDown ? (Math.PI * 0.5 + bp.exitAngle) : (-Math.PI * 0.5 + bp.exitAngle);
      const dstAngle = bp.goingDown ? (-Math.PI * 0.5 + bp.exitAngle * 0.7) : (Math.PI * 0.5 + bp.exitAngle * 0.7);

      const p0 = ellipsePoint(srcE, srcAngle);
      const p1 = ellipsePoint(dstE, dstAngle);

      // Smooth arc: lerp positions with easing, slight horizontal sway
      const t = bp.t;
      const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; // easeInOutQuad
      const sway = Math.sin(t * Math.PI) * 18 * Math.sin(bp.phase + time * 0.5);

      return {
        x: lerp(p0.x, p1.x, ease) + sway,
        y: lerp(p0.y, p1.y, ease),
      };
    }

    // ── Update ───────────────────────────────────────────────
    function update(dt) {
      time += dt;

      // 3D central axis rotation
      globalAngle += ROTATION_SPEED * dt;
      updateEllipse3D();

      // Node orbits
      for (const n of allNodes) {
        if (n !== dragging) {
          n.angle += n.baseSpeed * dt;
        }
        const e = ellipses[n.tier];
        const pt = ellipsePoint(e, n.angle);
        n.x = pt.x;
        n.y = pt.y;

        // Size animation
        n.targetSize = n.hovered ? n.baseSize * 1.65 : n.baseSize;
        n.size += (n.targetSize - n.size) * 0.12;
      }

      // Orbit particles
      for (const p of orbitParticles) {
        p.angle += p.speed * dt;
        const e = ellipses[p.tier];
        const pt = ellipsePoint(e, p.angle);
        p.x = pt.x;
        p.y = pt.y;
      }

      // Ambient particles
      for (const p of ambientParticles) {
        p.x += p.vx + Math.sin(time * 0.3 + p.phase) * 0.02;
        p.y += p.vy + Math.cos(time * 0.25 + p.phase) * 0.02;
        if (p.x < -20) p.x = W + 20;
        if (p.x > W + 20) p.x = -20;
        if (p.y < -20) p.y = H + 20;
        if (p.y > H + 20) p.y = -20;
      }

      // Bridge particles — inter-tier flow
      for (const bp of bridgeParticles) {
        bp.t += bp.speed * dt * 0.15;
        if (bp.t > 1) {
          bp.t -= 1;
          bp.goingDown = !bp.goingDown;          // reverse direction each pass
          bp.exitAngle = rand(-0.6, 0.6);        // new departure point
        }
        const pos = bridgePos(bp);
        bp.x = pos.x;
        bp.y = pos.y;

        // Trail
        bp.trail.unshift({ x: pos.x, y: pos.y });
        if (bp.trail.length > 6) bp.trail.pop();
      }

      // Hover detection
      if (!dragging) {
        let found = null;
        const hitRadius = W < 768 ? 24 : 18;
        for (const n of allNodes) {
          if (dist2(mouse.x, mouse.y, n.x, n.y) < (n.size + hitRadius) ** 2) {
            found = n;
            break;
          }
        }
        if (tappedNode) found = tappedNode;
        hovered = found;
        for (const n of allNodes) n.hovered = (n === hovered);
      }

      // Info panel
      if (hovered) {
        infoEl.classList.add('visible');
        document.getElementById('info-tier').textContent = hovered.tierLabel;
        document.getElementById('info-tier').style.color = TIERS[hovered.tier].color;
        document.getElementById('info-name').textContent = hovered.label;
        document.getElementById('info-desc').textContent = hovered.desc;

        let px = hovered.x + hovered.size + 18;
        let py = hovered.y - 30;
        if (px + 250 > W) px = hovered.x - 260;
        if (py < 10) py = 10;
        if (py + 110 > H) py = H - 110;
        infoEl.style.left = px + 'px';
        infoEl.style.top  = py + 'px';
      } else {
        infoEl.classList.remove('visible');
      }

      canvas.style.cursor = hovered && !dragging ? 'pointer' : dragging ? 'grabbing' : 'default';
    }

    // ── Draw ─────────────────────────────────────────────────
    function draw() {
      // Background
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, W, H);

      // Subtle radial vignette
      const vigGrad = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, Math.max(W, H) * 0.7);
      vigGrad.addColorStop(0, 'rgba(0,255,188,0.012)');
      vigGrad.addColorStop(0.5, 'rgba(0,177,255,0.006)');
      vigGrad.addColorStop(1, 'rgba(0,0,0,0.15)');
      ctx.fillStyle = vigGrad;
      ctx.fillRect(0, 0, W, H);

      // Subtle vertical spine connecting tier centres
      if (ellipses.length === 3) {
        const topE = ellipses[0], botE = ellipses[2];
        const grad = ctx.createLinearGradient(center.x, topE.cy, center.x, botE.cy);
        grad.addColorStop(0, 'rgba(0,177,255,0.04)');
        grad.addColorStop(0.5, 'rgba(0,255,188,0.06)');
        grad.addColorStop(1, 'rgba(23,206,149,0.04)');
        ctx.strokeStyle = grad;
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 9]);
        ctx.beginPath();
        ctx.moveTo(center.x, topE.cy - topE.ry - 15);
        ctx.lineTo(center.x, botE.cy + botE.ry + 15);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw ambient particles (behind rings)
      drawAmbientParticles();

      // Draw ellipse rings
      for (let i = 0; i < 3; i++) drawEllipseRing(i);

      // Draw orbit particles
      drawOrbitParticles();

      // Draw bridge particles (inter-tier flow)
      drawBridgeParticles();

      // Draw nodes — non-hovered first, then hovered on top
      for (const n of allNodes) { if (!n.hovered) drawNode(n); }
      for (const n of allNodes) { if (n.hovered)  drawNode(n); }

      // Draw tier labels (large, on top)
      for (let i = 0; i < 3; i++) drawTierLabel(i);
    }

    function drawEllipseRing(idx) {
      const e = ellipses[idx];
      const tier = TIERS[idx];
      const rgb = hexRgb(tier.color);

      ctx.save();
      ctx.translate(e.cx, e.cy);
      ctx.rotate(e.rotation);

      // Soft glow ring
      ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.035)`;
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.rx, e.ry, 0, 0, TAU);
      ctx.stroke();

      // Main ring — dashed
      ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.12)`;
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 10]);
      ctx.beginPath();
      ctx.ellipse(0, 0, e.rx, e.ry, 0, 0, TAU);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.restore();
    }

    function drawNode(n) {
      const breathe = 1 + Math.sin(time * 1.5 + n.phase) * 0.03;
      const r = n.size * breathe;
      const { rgb } = n;
      const hi = n.hovered ? 1 : 0;

      // Outer glow
      const glowR = r * (2.5 + hi * 1.5);
      const grad = ctx.createRadialGradient(n.x, n.y, r * 0.2, n.x, n.y, glowR);
      grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${lerp(0.08, 0.22, hi)})`);
      grad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},${lerp(0.02, 0.08, hi)})`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(n.x, n.y, glowR, 0, TAU);
      ctx.fill();

      // Main circle
      ctx.beginPath();
      ctx.arc(n.x, n.y, r, 0, TAU);
      ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${lerp(0.4, 0.75, hi)})`;
      ctx.fill();

      // Inner bright core
      ctx.beginPath();
      ctx.arc(n.x, n.y, r * 0.35, 0, TAU);
      ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`;
      ctx.fill();

      // Hover ring pulse
      if (hi > 0.01) {
        const pulseR = r + 6 + Math.sin(time * 3) * 3;
        ctx.beginPath();
        ctx.arc(n.x, n.y, pulseR, 0, TAU);
        ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.25 * hi})`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      // Label
      const labelAlpha = lerp(0.5, 0.95, hi);
      const labelWeight = n.hovered ? 600 : 400;
      const labelSize = n.hovered ? 12 : 10;
      ctx.font = `${labelWeight} ${labelSize}px 'Poppins',sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = `rgba(255,255,255,${labelAlpha})`;
      ctx.fillText(n.label, n.x, n.y + r + 15);
    }

    function drawTierLabel(idx) {
      const e = ellipses[idx];
      const tier = TIERS[idx];
      const rgb = hexRgb(tier.color);

      // Tier name — LARGE, centred in the ellipse
      const isMobile = W < 768;
      const mainSize = isMobile ? 18 : 24;
      ctx.font = `700 ${mainSize}px 'Poppins',sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.30)`;
      ctx.fillText(tier.label.toUpperCase(), e.cx, e.cy + mainSize * 0.35);

      // Subtitle below
      const subSize = isMobile ? 10 : 12;
      ctx.font = `300 ${subSize}px 'Poppins',sans-serif`;
      ctx.fillStyle = 'rgba(255,255,255,0.14)';
      ctx.fillText(tier.sub, e.cx, e.cy + mainSize * 0.35 + subSize + 6);
    }

    function drawOrbitParticles() {
      for (const p of orbitParticles) {
        if (p.x === undefined) continue;
        const breathe = 1 + Math.sin(time * 2.5 + p.phase) * 0.25;
        const flicker = 0.5 + Math.sin(time * 1.2 + p.phase * 2) * 0.35;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * breathe, 0, TAU);
        ctx.fillStyle = `rgba(${p.rgb.r},${p.rgb.g},${p.rgb.b},${p.alpha * flicker})`;
        ctx.fill();
      }
    }

    function drawAmbientParticles() {
      for (const p of ambientParticles) {
        const breathe = 1 + Math.sin(time * 1.2 + p.phase) * 0.3;
        const flicker = 0.5 + Math.sin(time * 0.7 + p.phase * 3) * 0.35;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * breathe, 0, TAU);
        ctx.fillStyle = `rgba(${p.rgb.r},${p.rgb.g},${p.rgb.b},${p.alpha * flicker})`;
        ctx.fill();
      }
    }

    function drawBridgeParticles() {
      for (const bp of bridgeParticles) {
        if (bp.x === undefined) continue;

        // Determine colour — blend between source and destination tier
        const srcIdx = bp.goingDown ? bp.junction : bp.junction + 1;
        const dstIdx = bp.goingDown ? bp.junction + 1 : bp.junction;
        const srcRgb = hexRgb(TIERS[srcIdx].color);
        const dstRgb = hexRgb(TIERS[dstIdx].color);
        const t = bp.t;
        const r = Math.round(lerp(srcRgb.r, dstRgb.r, t));
        const g = Math.round(lerp(srcRgb.g, dstRgb.g, t));
        const b = Math.round(lerp(srcRgb.b, dstRgb.b, t));

        // Trail
        for (let i = 0; i < bp.trail.length; i++) {
          const tp = bp.trail[i];
          const trailAlpha = (1 - i / bp.trail.length) * bp.alpha * 0.5;
          const trailSize = bp.size * (1 - i / bp.trail.length * 0.4);
          ctx.beginPath();
          ctx.arc(tp.x, tp.y, trailSize, 0, TAU);
          ctx.fillStyle = `rgba(${r},${g},${b},${trailAlpha})`;
          ctx.fill();
        }

        // Main particle
        const flicker = 0.6 + Math.sin(time * 2 + bp.phase) * 0.3;
        ctx.beginPath();
        ctx.arc(bp.x, bp.y, bp.size, 0, TAU);
        ctx.fillStyle = `rgba(${r},${g},${b},${bp.alpha * flicker})`;
        ctx.fill();

        // Subtle glow
        const glowGrad = ctx.createRadialGradient(bp.x, bp.y, 0, bp.x, bp.y, bp.size * 4);
        glowGrad.addColorStop(0, `rgba(${r},${g},${b},${bp.alpha * 0.15})`);
        glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(bp.x, bp.y, bp.size * 4, 0, TAU);
        ctx.fill();
      }
    }

    // ── Events ───────────────────────────────────────────────
    function hideHint() {
      if (!interacted) {
        interacted = true;
        hintEl.classList.add('hidden');
      }
    }

    canvas.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      hideHint();

      if (dragging) {
        const ell = ellipses[dragging.tier];
        const dx = mouse.x - ell.cx;
        const dy = mouse.y - ell.cy;
        const cr = Math.cos(-ell.rotation), sr = Math.sin(-ell.rotation);
        const lx = dx * cr - dy * sr;
        const ly = dx * sr + dy * cr;
        dragging.angle = Math.atan2(ly / ell.ry, lx / ell.rx);

        // Log interaction to parent
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'LOG_INTERACTION',
            action: 'drag_node',
            nodeLabel: dragging.label,
            timestamp: Date.now()
          }, '*');
        }
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      if (hovered) {
        dragging = hovered;
        canvas.style.cursor = 'grabbing';
      }
    });

    window.addEventListener('mouseup', () => {
      if (dragging) {
        dragging = null;
        canvas.style.cursor = hovered ? 'pointer' : 'default';
      }
    });

    // Touch events
    let touchStart = { x: 0, y: 0, time: 0 };

    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      mouse.x = touch.clientX;
      mouse.y = touch.clientY;
      touchStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
      hideHint();

      const hitRadius = 28;
      for (const n of allNodes) {
        if (dist2(mouse.x, mouse.y, n.x, n.y) < (n.size + hitRadius) ** 2) {
          dragging = n;
          n.hovered = true;
          hovered = n;
          e.preventDefault();

          // Log interaction to parent
          if (window.parent !== window) {
            window.parent.postMessage({
              type: 'LOG_INTERACTION',
              action: 'touch_node',
              nodeLabel: n.label,
              timestamp: Date.now()
            }, '*');
          }
          return;
        }
      }
      tappedNode = null;
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      mouse.x = touch.clientX;
      mouse.y = touch.clientY;

      if (dragging) {
        e.preventDefault();
        const ell = ellipses[dragging.tier];
        const dx = mouse.x - ell.cx;
        const dy = mouse.y - ell.cy;
        const cr = Math.cos(-ell.rotation), sr = Math.sin(-ell.rotation);
        const lx = dx * cr - dy * sr;
        const ly = dx * sr + dy * cr;
        dragging.angle = Math.atan2(ly / ell.ry, lx / ell.rx);
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      const elapsed = Date.now() - touchStart.time;
      const moved = Math.hypot(mouse.x - touchStart.x, mouse.y - touchStart.y);

      if (dragging && elapsed < 300 && moved < 15) {
        if (tappedNode === dragging) {
          tappedNode = null;
        } else {
          tappedNode = dragging;
        }
      }

      if (dragging) {
        if (!tappedNode || tappedNode !== dragging) {
          dragging.hovered = false;
        }
        dragging = null;
      }

      if (!tappedNode) {
        hovered = null;
        for (const n of allNodes) n.hovered = false;
      }

      mouse.x = -9999;
      mouse.y = -9999;
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.x = -9999;
      mouse.y = -9999;
    });

    // ── Init & loop ──────────────────────────────────────────
    function init() {
      resize();
      computeEllipses();
      createNodes();
      createParticles();

      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          resize();
          computeEllipses();
          createNodes();
          createParticles();
        }, 200);
      });

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduced) {
        update(0.5);
        draw();
        return;
      }

      let last = performance.now();
      function frame(now) {
        const dt = Math.min((now - last) / 1000, 0.1);
        last = now;
        update(dt);
        draw();
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      // Signal ready to parent frame
      postMessageReady();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
  </script>
</body>
</html>
